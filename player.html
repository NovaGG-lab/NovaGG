<!DOCTYPE html>
<html>
<head>
  <title>NovaGG Player</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    canvas { display: block; }
    #chat {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 10px;
      max-width: 300px;
      color: white;
    }
    #messages {
      max-height: 150px;
      overflow-y: auto;
      font-size: 14px;
    }
    #messageInput {
      width: 100%;
    }
  </style>
</head>
<body>
  <div id="chat">
    <div id="messages"></div>
    <input type="text" id="messageInput" placeholder="Type a message..." />
  </div>

  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>

  <script>
    const socket = io("http://localhost:3000");

    let scene, camera, renderer, myId, isFirstPerson = false;
    const players = {};

    // Chat filter (very basic)
    const bannedWords = ['fuck', 'shit', 'bitch', 'ass']; // Add more as needed
    const filterMessage = (msg) => {
      const regex = new RegExp(bannedWords.join('|'), 'gi');
      return msg.replace(regex, '****');
    };

    // HTML chat elements
    const messagesDiv = document.getElementById('messages');
    const messageInput = document.getElementById('messageInput');
    messageInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && messageInput.value.trim()) {
        const msg = filterMessage(messageInput.value.trim());
        socket.emit('chat', msg);
        messageInput.value = '';
      }
    });

    socket.on('chat', ({ username, message }) => {
      const msgEl = document.createElement('div');
      msgEl.textContent = `${username}: ${message}`;
      messagesDiv.appendChild(msgEl);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    });

    // Scene Setup
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const baseplate = new THREE.Mesh(
        new THREE.BoxGeometry(100, 1, 100),
        new THREE.MeshBasicMaterial({ color: 0x333333 })
      );
      baseplate.position.y = -0.5;
      scene.add(baseplate);

      camera.position.y = 2;
      camera.position.z = 5;

      // Switch camera mode on keypress
      window.addEventListener('keydown', (e) => {
        if (e.key === 'v') {
          isFirstPerson = !isFirstPerson;
        }
      });

      animate();
    }

    function createCapsule() {
      const group = new THREE.Group();

      const cylinder = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8),
        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
      );
      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.5, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
      );
      head.position.y = 1;

      const nameTag = document.createElement('div');
      nameTag.style.position = 'absolute';
      nameTag.style.color = 'white';
      nameTag.style.fontSize = '12px';
      nameTag.style.fontWeight = 'bold';
      nameTag.classList.add('nameTag');
      document.body.appendChild(nameTag);

      group.add(cylinder);
      group.add(head);
      return { group, nameTag };
    }

    function updateNameTags() {
      Object.values(players).forEach(({ group, nameTag, username }) => {
        const vector = group.position.clone().project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        nameTag.style.left = `${x}px`;
        nameTag.style.top = `${y}px`;
        nameTag.textContent = username;
      });
    }

    function animate() {
      requestAnimationFrame(animate);

      if (myId && players[myId]) {
        const me = players[myId];
        camera.position.copy(me.group.position);
        if (isFirstPerson) {
          camera.position.y += 1;
          camera.lookAt(me.group.position.x, me.group.position.y + 1, me.group.position.z + 1);
        } else {
          camera.position.z = me.group.position.z + 5;
          camera.lookAt(me.group.position);
        }
      }

      renderer.render(scene, camera);
      updateNameTags();
    }

    // Socket Events
    socket.on("connect", () => {
      const username = prompt("Enter your username:").substring(0, 16);
      myId = socket.id;
      socket.emit("join", { username });
    });

    socket.on("playerData", (data) => {
      data.forEach(({ id, username, position }) => {
        if (!players[id]) {
          const { group, nameTag } = createCapsule();
          scene.add(group);
          group.position.set(position?.x || 0, 0, position?.z || 0);
          players[id] = { group, nameTag, username };
        }
      });
    });

    socket.on("playerMoved", ({ id, position }) => {
      if (players[id]) {
        players[id].group.position.set(position.x, 0, position.z);
      }
    });

    socket.on("playerLeft", (id) => {
      if (players[id]) {
        scene.remove(players[id].group);
        document.body.removeChild(players[id].nameTag);
        delete players[id];
      }
    });

    window.addEventListener("beforeunload", () => {
      socket.emit("leave");
    });

    init();
  </script>
</body>
</html>
